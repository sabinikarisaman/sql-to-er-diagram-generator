from flask import Flask, request, jsonify, send_from_directory
import os
from dotenv import load_dotenv 
load_dotenv() 
import sys
import requests
import json
import time
import random
from colorama import Fore, Style
import colorama

# Initialize colorama
colorama.init()

class Colors:
    """Color constants for terminal output"""
    RED = Fore.RED
    GREEN = Fore.GREEN
    YELLOW = Fore.YELLOW
    BLUE = Fore.BLUE
    RESET = Style.RESET_ALL

app = Flask(__name__)

class SchemaMermaidGenerator:
    """
    Final robust class for converting schemas to Mermaid diagrams.
    Uses the 'flash' model for higher rate limits and includes automatic retries.
    """

    def __init__(self):
        self.api_key = os.getenv('GEMINI_API_KEY')
        # Using gemini-1.5-flash for its higher rate limit, which is better for this app.
        self.api_url = "https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent"

    def validate_api_key(self) -> None:
        if not self.api_key:
            error_msg = "Error: GEMINI_API_KEY environment variable is not set"
            print(f"{Colors.RED}{error_msg}{Colors.RESET}", file=sys.stderr)
            raise ValueError(error_msg)

    def create_prompt(self, schema_content: str) -> str:
        # This highly-structured prompt is optimized for accuracy.
        return f"""
You are an expert system designed to convert SQL DDL to Mermaid ER diagrams. Your task is to analyze the provided SQL and generate a syntactically perfect Mermaid `erDiagram`. You must follow all rules precisely.

Your internal process should be:
1. Identify all tables and their names from the `CREATE TABLE` statements.
2. For each table, list its columns.
3. Simplify all data types to generic Mermaid-compatible types (e.g., `VARCHAR(255)` becomes `string`, `DECIMAL(10,2)` becomes `decimal`, `INT` becomes `int`).
4. Identify the primary key (`PK`) for each table.
5. Identify all foreign key relationships (`FK`) and the tables they connect.
6. Assemble the final `erDiagram` code according to the strict rules below.

---
## CRITICAL RULES
1.  **OUTPUT FORMAT:** Your entire response must be ONLY the raw Mermaid code. It MUST start with `erDiagram`. Do NOT include the markdown code block fences (```mermaid ... ```) or any explanations.
2.  **DATA TYPES:** Use only generic types: `int`, `string`, `text`, `date`, `timestamp`, `decimal`, `boolean`.
3.  **COLUMN DEFINITIONS:** A column definition must only contain the data type and the column name. Do NOT include any other SQL keywords like `NOT NULL`, `UNIQUE`, `DEFAULT`, `AUTO_INCREMENT`, or `CURRENT_TIMESTAMP`.
4.  **KEYS:** Mark primary keys with `PK` and foreign keys with `FK` immediately after the column name.
5.  **RELATIONSHIPS:** Define relationships clearly *after* all table blocks. Use the format: `TABLE_A ||--o{{ TABLE_B : "label"`.

---
## COMPLETE EXAMPLE

### Input SQL:
CREATE TABLE users ( id INT PRIMARY KEY, email VARCHAR(100) UNIQUE NOT NULL );
CREATE TABLE profiles ( profile_id INT PRIMARY KEY, user_id INT, bio TEXT, FOREIGN KEY (user_id) REFERENCES users(id) );

### Your Required Output:
erDiagram
    users {{
        int id PK
        string email
    }}
    profiles {{
        int profile_id PK
        int user_id FK
        text bio
    }}
    users ||--o{{ profiles : "has"

---
Now, process the following SQL and generate the Mermaid code.

## INPUT SQL
{schema_content}
"""

    def call_gemini_api(self, schema_content: str) -> str:
        """Calls the Gemini API with automatic retries for rate limiting."""
        self.validate_api_key()

        prompt = self.create_prompt(schema_content)
        generation_config = {"temperature": 0.2}
        payload = {"contents": [{"parts": [{"text": prompt}]}], "generationConfig": generation_config}
        headers = {'Content-Type': 'application/json'}
        
        max_retries = 5
        base_wait_time = 1.0

        for i in range(max_retries):
            try:
                print(f"{Colors.YELLOW}Calling Gemini 1.5 Flash API (Attempt {i+1})...{Colors.RESET}", file=sys.stderr)
                response = requests.post(
                    f"{self.api_url}?key={self.api_key}",
                    headers=headers,
                    json=payload,
                    timeout=90 # 90s is plenty for the fast flash model
                )
                response.raise_for_status()

                response_data = response.json()
                mermaid_code = response_data['candidates'][0]['content']['parts'][0]['text']

                if not mermaid_code.strip():
                    raise RuntimeError("Error: No content generated by API")

                if "```mermaid" in mermaid_code:
                    mermaid_code = mermaid_code.split("```mermaid")[1].split("```")
                elif "```" in mermaid_code:
                    mermaid_code = mermaid_code.replace("```", "")
                
                return mermaid_code.strip()

            except requests.exceptions.RequestException as e:
                if e.response is not None and e.response.status_code == 429:
                    if i < max_retries - 1:
                        wait_time = base_wait_time * (2 ** i) + random.uniform(0, 1)
                        print(f"{Colors.RED}Rate limit hit. Retrying in {wait_time:.2f} seconds...{Colors.RESET}", file=sys.stderr)
                        time.sleep(wait_time)
                    else:
                        print(f"{Colors.RED}Rate limit hit. Max retries reached. Aborting.{Colors.RESET}", file=sys.stderr)
                        raise RuntimeError("API rate limit exceeded after multiple retries.") from e
                else:
                    raise RuntimeError(f"An unexpected API error occurred: {e}") from e
        
        raise RuntimeError("Failed to get a response from the API after all retries.")


@app.route('/')
def index():
    return send_from_directory('.', 'index.html')


@app.route('/generate_mermaid', methods=['POST'])
def generate_mermaid():
    try:
        sql_ddl = request.json.get('sql_ddl')
        if not sql_ddl:
            return jsonify({'error': 'SQL DDL is required'}), 400

        generator = SchemaMermaidGenerator()
        mermaid_code = generator.call_gemini_api(sql_ddl)
        print(f"{Colors.GREEN}Successfully generated Mermaid code.{Colors.RESET}", file=sys.stderr)
        return jsonify({'mermaid_code': mermaid_code}), 200

    except (ValueError, RuntimeError) as e:
        print(f"{Colors.RED}Server Error: {e}{Colors.RESET}", file=sys.stderr)
        return jsonify({'error': str(e)}), 500
    except Exception as e:
        print(f"{Colors.RED}An unexpected error occurred: {e}{Colors.RESET}", file=sys.stderr)
        return jsonify({'error': 'An internal server error occurred'}), 500


if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000, debug=True)